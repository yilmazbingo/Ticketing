## SSR getInitialProps failed in kubernetes

- if i fetch data in component from the browser, it works. we are making request from ticketing.dev but since I cahnged the host file, it will be read as request from 127.0.0.1:80. since i did not specify port, it is set to be 80. that host is bound to ingress nginx. anytime we make request to that ip, ingress nginx is going to receive that req and read it off appropriately. since we are making request to tickeing.dev, without any path, ingress nginx decides to send that request on to our client app. after browser got the html, it made the follow up axios request. "axios.get("/api/users/currentuser")" goes to "ticketing.dev/api/users/currentuser"
- when we make a request from ssr, in getINitialProps, our request will be handled by node http layer. if we do not specify a domain there, the node http layer is going to assume that we are making req on our local machine. so it will automatically stick "localhost" domain."localhost:80/api/users/currentuser"
- we are running our next app inside a container. request to "localhost:80/api/users/currentuser" is inside of that container. it was not forwarded back to ingress nginx. node http layer will make "localhost:80/api/users/currentuser" inside the container and there is nothing running.
- 1st solution: in auth-depl yaml file, we set metadata name as: auth-srv. so inside next.js during ssr fetching we could make request to "http://auth-srv/api/users/currentuser". this is not a good option, that implies our react client code, will know the exact service name for every things it is ewer want to reach out. in the future we could make request to different service so we gotta change the base url eveytime we make request to a different service.
- 2.solution is to make request to ingress nginx. it already has set of relevant "rules". the challenge is what domain we are making request to. how do we somehow reach out to ingress nginx while we are inside of some pod. we can very easily reach out to ingress nginx from our local machine by just making request to localhost:80 or as we set it up ticketing.dev. but how do we do that same kind of thing when we are already inside the cluster. we need to figure out how to make a request directly to ingress nginx when we are inside the cluster. another challenge is our current authentication mechanism works based upon cookies. we need to keep in mind, we have some requests coming into our next.js app and it includes a cookie, and some point in time we are going to make a follow up request from inside of next.js and that follow up request is probably going to have to include that cookie information . when we execute the fething rrequest for current user inside getInitialProps, we do not have the browser automatically manage that cookie or anything like that.
  so we are going to reach ingress-nginx and it will handle the request.

## Make request to Ingress nginx from next.js pod

- two pods communicate each other with ClusterIp service. if Client Pod wants to reach Auth POd, CLient Pod will reach to Auth CLusterIp service. "http://auth-srv". this rule works only when we access a service that is inside in the same namespace. Namespace exist in the world of k8s. All the different objects that we create are crated under a specific namespace. we use namespaces to organize different objects. right now we have been working under a namepace called "default".
  `kubectl get namespace`
  u will see ingress nginx namespace. this is where all ingress nginx stuffs work. so we want to communicate from "default" namespace to "ingress nginx" namespace.
  `http://NAMEOFSERVICE.NAMESPACE.svc.cluster.local`
  we now have to get the services inside the "ingress nginx" namespace. `kubectl get services` will get the services inside the default namespace.
- `kubectl get services -n ingress-nginx`
  since the name of the external namepsace name will be ugly, we could create external Name service. it just remaps the domain of a request. but we are not.

## Get Initial Props

if we have request from a component that is always issued from the browser. during ssr process, getInitialProps gets called one time. we can make some requests and pass the response as a prop to the component. we could make requests inisd the component, we do not have opportunity to wait for the request to be resolved during the ssr. we dont get the ability to update any state, make use of any lifecycle methods or anything like that. all the components just get executed or rendered one time and whatever they return is immediately sent back down to the browser.

getInitialProps will also be executed in the browser under som every particular circumstances. hard refresh of page, clicking link from different domain or typing url into address bar, getInitialProps executed on the server.

when we navigate from one page to another while we are inside of our application already. For example when i signed up the form, i am programmatically navigated to "/" index page. so getInitialProps of landig page will be executed on the browser.

We can create <Header> and render inside <app.js> but if we have multiple getinitialProps, in pages and \_app.js (\_app.js is not conisdered to ba a page.).\_app is a custom component that will wrap up the page. The arguments that provided to <getInitialProps> for a page are different than the arguments provided for the custom app component. in Page componetn first argument is <context===(req,res)>. req has the headers that was coming into our application from the user's browser. but in <custom _app>, argument is <context==={Component,ctx:{req,res}}>, req is nested. when we tie initialProps to app components, the getInitial functions we tie to individual page do not get automatically invoked anymore. solution is we are gonna invoke page's getInitialProps inside the custom \_app manually. we are going to be fetching two sets of data.
